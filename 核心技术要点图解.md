# 🎯 WebMind 核心技术要点图解

> 用图表和简洁的语言理解项目的核心技术

---

## 1. 整体数据流

```
┌─────────────────────────────────────────────────────────┐
│                       用户操作                           │
│              在网页上选中一段文字                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│               Content Script (content.ts)               │
│  ┌──────────────────────────────────────────────────┐   │
│  │ 1. 监听 mouseup 事件                              │   │
│  │ 2. 获取选中文本 window.getSelection()            │   │
│  │ 3. 显示浮动按钮                                   │   │
│  │ 4. 用户点击 → 发送消息                           │   │
│  └──────────────────────────────────────────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │ chrome.runtime.sendMessage
                     │ { type: 'COLLECT_TEXT', payload: {...} }
                     ▼
┌─────────────────────────────────────────────────────────┐
│         Background Service Worker (service-worker.ts)   │
│  ┌──────────────────────────────────────────────────┐   │
│  │ 1. 接收消息（消息路由中心）                       │   │
│  │ 2. 创建笔记对象                                   │   │
│  │ 3. 调用 Offscreen Document                       │   │
│  │ 4. 保存笔记到 Storage                            │   │
│  └──────────────────────────────────────────────────┘   │
└─────┬────────────────────────────────────┬──────────────┘
      │                                    │
      │ 创建/通信                          │ 保存
      ▼                                    ▼
┌──────────────────────────┐    ┌──────────────────────────┐
│  Offscreen Document      │    │   Chrome Storage API     │
│  (offscreen.ts)          │    │  (chrome.storage.local)  │
│ ┌────────────────────┐   │    │ ┌────────────────────┐   │
│ │ 调用 AI API：      │   │    │ │ webmind_notes: [  │   │
│ │ window.ai          │   │    │ │   { id, content,  │   │
│ │   .summarizer      │   │    │ │     summary, ... }│   │
│ │   .create()        │   │    │ │ ]                 │   │
│ │   .summarize()     │   │    │ └────────────────────┘   │
│ └────────────────────┘   │    └──────────────────────────┘
└──────────┬───────────────┘
           │ 返回摘要
           ▼
┌─────────────────────────────────────────────────────────┐
│              用户界面（查看笔记）                         │
│  ┌──────────────┐           ┌──────────────────────┐    │
│  │   Popup      │           │    Side Panel        │    │
│  │ 最近3条笔记   │           │  ┌────────────────┐  │    │
│  └──────────────┘           │  │  笔记列表视图   │  │    │
│                             │  │  (网格布局)     │  │    │
│                             │  └────────────────┘  │    │
│                             │  ┌────────────────┐  │    │
│                             │  │  思维导图视图   │  │    │
│                             │  │  (D3.js)       │  │    │
│                             │  └────────────────┘  │    │
│                             └──────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

---

## 2. Offscreen Document 架构（核心难点）

### 问题：为什么需要 Offscreen Document？

```
Manifest V3 规范:
┌─────────────────────────────────────────┐
│  Service Worker (service-worker.ts)     │
│  ❌ 没有 DOM 环境                        │
│  ❌ 没有 window 对象                     │
│  ❌ 不能调用 window.ai                   │
│  ✅ 可以处理消息                         │
│  ✅ 可以访问 Chrome API                  │
└─────────────────────────────────────────┘

Chrome Built-in AI 要求:
┌─────────────────────────────────────────┐
│  ✅ 需要 DOM 环境                        │
│  ✅ 需要 window 对象                     │
│  ✅ 需要用户激活（user activation）      │
└─────────────────────────────────────────┘

矛盾！🤔
```

### 解决方案：Offscreen Document

```
┌──────────────────────────────────────────────────────┐
│  Background Service Worker                           │
│                                                      │
│  async function callAI(text) {                       │
│    // 1. 检查是否已有 Offscreen Document            │
│    const contexts = await chrome.runtime             │
│      .getContexts({ contextTypes: ['OFFSCREEN'] });  │
│                                                      │
│    // 2. 如果没有，创建一个                          │
│    if (contexts.length === 0) {                      │
│      await chrome.offscreen.createDocument({         │
│        url: 'background/offscreen.html',             │
│        reasons: ['DOM_SCRAPING'],                    │
│        justification: '使用 Chrome AI'               │
│      });                                             │
│    }                                                 │
│                                                      │
│    // 3. 发送消息到 Offscreen                        │
│    const response = await chrome.runtime             │
│      .sendMessage({                                  │
│        type: 'AI_SUMMARIZE',                         │
│        payload: { text }                             │
│      });                                             │
│                                                      │
│    return response.summary;                          │
│  }                                                   │
└────────────────┬─────────────────────────────────────┘
                 │
                 │ 消息传递
                 ▼
┌──────────────────────────────────────────────────────┐
│  Offscreen Document (offscreen.html + offscreen.ts)  │
│  ✅ 有 DOM 环境                                       │
│  ✅ 不可见（用户看不到）                              │
│  ✅ 可以调用 window.ai                                │
│                                                      │
│  chrome.runtime.onMessage.addListener(async (msg) => {
│    if (msg.type === 'AI_SUMMARIZE') {               │
│      // 调用 AI API                                  │
│      const summarizer = await window.ai              │
│        .summarizer.create({                          │
│          type: 'tldr',                               │
│          format: 'plain-text',                       │
│          length: 'medium'                            │
│        });                                           │
│                                                      │
│      const summary = await summarizer                │
│        .summarize(msg.payload.text);                 │
│                                                      │
│      summarizer.destroy(); // 释放资源               │
│                                                      │
│      return { summary };                             │
│    }                                                 │
│  });                                                 │
└──────────────────────────────────────────────────────┘
```

### 面试要点

**问题**：Chrome Built-in AI 需要 DOM，但 Service Worker 没有 DOM

**方案**：创建不可见的 Offscreen Document 作为代理

**优化**：
1. 复用 Offscreen Document（不重复创建）
2. 用完及时销毁（释放内存）
3. 降级方案（AI 不可用时用简单算法）

---

## 3. D3.js 力导向图原理（难点）

### 四种力的作用

```
1. Link Force (弹簧力) - 把有连线的节点拉到一起
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  [节点A]  ←─────弹簧─────→  [节点B]
                ↑
                │
          理想距离 150px
          
  - 距离太远 → 拉近
  - 距离太近 → 推开


2. Charge Force (电荷力) - 所有节点互相排斥
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        [节点A]
          ↓  ↘  ↓  ↙  ↓   排斥力
        [节点B] [节点C] [节点D]
          
  strength = -500 (负数表示排斥)
  就像同性电荷，互相推开


3. Center Force (中心力) - 把整个图拉向中心
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ┌──────────────────────────┐
  │                          │
  │      [A]    [B]          │
  │        ↘  ↙              │
  │         ●  ← 中心         │
  │        ↗  ↖              │
  │      [C]    [D]          │
  │                          │
  └──────────────────────────┘
  
  防止节点飞出视野


4. Collision Force (碰撞力) - 防止节点重叠
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

      ╭───────╮
      │ 节点A │  ← 安全区域 60px
      ╰───────╯
         ↕
     最小间距
         ↕
      ╭───────╮
      │ 节点B │
      ╰───────╯
```

### 物理模拟过程

```
初始状态（节点随机分布）：
┌──────────────────────────┐
│  [A]                     │
│        [B]          [C]  │
│                          │
│   [D]        [E]         │
│                    [F]   │
└──────────────────────────┘

第 1 帧（开始运动）：
┌──────────────────────────┐
│  [A]→                    │
│      ↙[B]←        [C]↓   │
│                 ●        │
│   [D]↗      ↗[E]         │
│                  ↑[F]    │
└──────────────────────────┘

第 10 帧（运动中）：
┌──────────────────────────┐
│     [A]                  │
│   ↙  ↓  ↘                │
│ [D]  ●  [B]              │
│   ↖  ↑  ↗                │
│    [E] [C]         [F]   │
└──────────────────────────┘

第 100 帧（接近平衡）：
┌──────────────────────────┐
│         [A]              │
│        ╱│╲               │
│      [D]│[B]             │
│         │                │
│        [E]─[C]─[F]       │
└──────────────────────────┘

第 300 帧（达到平衡）：
┌──────────────────────────┐
│         [A]              │
│        ╱│╲               │
│      [D] ● [B]           │
│         │ ╲              │
│        [E]─[C]─[F]       │
└──────────────────────────┘
         ↑
     最终布局
```

### 代码实现

```typescript
// 1. 准备数据
const nodes = [
  { id: 'A', label: 'React' },
  { id: 'B', label: 'TypeScript' },
  { id: 'C', label: 'Vite' },
  // ...
];

const links = [
  { source: 'A', target: 'B' },  // React 和 TypeScript 有关联
  { source: 'B', target: 'C' },  // TypeScript 和 Vite 有关联
  // ...
];

// 2. 创建力模拟
const simulation = d3.forceSimulation(nodes)
  .force('link', d3.forceLink(links)
    .id(d => d.id)
    .distance(150))              // 弹簧力，理想距离 150px
    
  .force('charge', d3.forceManyBody()
    .strength(-500))              // 电荷力，排斥强度 -500
    
  .force('center', d3.forceCenter(width / 2, height / 2))  // 中心力
  
  .force('collision', d3.forceCollide()
    .radius(60));                 // 碰撞力，安全半径 60px

// 3. 监听每一帧，更新 UI
simulation.on('tick', () => {
  // 更新连线位置
  linkElements
    .attr('x1', d => d.source.x)
    .attr('y1', d => d.source.y)
    .attr('x2', d => d.target.x)
    .attr('y2', d => d.target.y);
    
  // 更新节点位置
  nodeElements
    .attr('cx', d => d.x)
    .attr('cy', d => d.y);
});
```

### 面试要点

**问题**：如何自动布局节点？

**方案**：D3.js 力导向图（物理模拟）

**原理**：
- 4种力：弹簧、电荷、中心、碰撞
- 每帧计算节点受力 → 更新位置
- 重复迭代直到平衡

**优点**：自动布局，无需手动计算坐标

---

## 4. Chrome 扩展的 5 个运行环境

```
┌─────────────────────────────────────────────────────────┐
│                    Chrome 浏览器                         │
│                                                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Content      │  │   Popup      │  │ Side Panel   │  │
│  │ Script       │  │              │  │              │  │
│  ├──────────────┤  ├──────────────┤  ├──────────────┤  │
│  │ 运行环境：    │  │ 运行环境：    │  │ 运行环境：    │  │
│  │ 网页中       │  │ 独立页面     │  │ 独立页面     │  │
│  │              │  │              │  │              │  │
│  │ 能访问：      │  │ 能访问：      │  │ 能访问：      │  │
│  │ ✅ 网页DOM   │  │ ❌ 网页DOM   │  │ ❌ 网页DOM   │  │
│  │ ✅ Chrome API│  │ ✅ Chrome API│  │ ✅ Chrome API│  │
│  │ ❌ 扩展页面  │  │ ✅ 扩展页面  │  │ ✅ 扩展页面  │  │
│  │              │  │              │  │              │  │
│  │ 生命周期：    │  │ 生命周期：    │  │ 生命周期：    │  │
│  │ 页面加载时   │  │ 点击图标时   │  │ 打开侧栏时   │  │
│  │ 注入         │  │ 打开         │  │ 加载         │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
│         ↓                 ↓                 ↓           │
│         └─────────────────┴─────────────────┘           │
│                           │                             │
│                           ▼                             │
│  ┌─────────────────────────────────────────────────┐   │
│  │       Background Service Worker                 │   │
│  ├─────────────────────────────────────────────────┤   │
│  │ 运行环境：独立的 Worker 线程                     │   │
│  │                                                 │   │
│  │ 能访问：                                         │   │
│  │ ❌ 网页 DOM                                     │   │
│  │ ❌ window 对象                                  │   │
│  │ ✅ Chrome API                                   │   │
│  │ ✅ 消息传递                                      │   │
│  │                                                 │   │
│  │ 生命周期：事件驱动，不持久运行                   │   │
│  │ - 收到消息时唤醒                                 │   │
│  │ - 空闲 30 秒后休眠                               │   │
│  └─────────────────────────────────────────────────┘   │
│                           │                             │
│                           ▼                             │
│  ┌─────────────────────────────────────────────────┐   │
│  │       Offscreen Document                        │   │
│  ├─────────────────────────────────────────────────┤   │
│  │ 运行环境：不可见的页面                           │   │
│  │                                                 │   │
│  │ 能访问：                                         │   │
│  │ ✅ DOM / window                                 │   │
│  │ ✅ Chrome API                                   │   │
│  │ ✅ window.ai (关键!)                            │   │
│  │                                                 │   │
│  │ 生命周期：按需创建，用完可销毁                   │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 通信方式

```
Content Script → Background:
chrome.runtime.sendMessage({ type: 'XXX', payload: {...} })

Background → Content Script:
chrome.tabs.sendMessage(tabId, { type: 'XXX', payload: {...} })

Background ↔ Popup/SidePanel:
chrome.runtime.sendMessage({ type: 'XXX', payload: {...} })

Background ↔ Offscreen:
chrome.runtime.sendMessage({ type: 'XXX', payload: {...} })
```

---

## 5. Zustand 状态管理

### 为什么选 Zustand？

```
Redux:
┌─────────────────────────────────────┐
│  体积大（10KB+）                     │
│  需要 Provider 包裹                  │
│  需要 actions、reducers、dispatch   │
│  样板代码多                          │
└─────────────────────────────────────┘

Context API:
┌─────────────────────────────────────┐
│  简单易用                            │
│  但性能差（所有消费者都重渲染）      │
│  多 Context 嵌套地狱                │
└─────────────────────────────────────┘

Zustand:
┌─────────────────────────────────────┐
│  体积小（1KB）✅                     │
│  无需 Provider ✅                    │
│  API 简洁 ✅                        │
│  性能好（选择性订阅）✅              │
│  TypeScript 支持好 ✅               │
└─────────────────────────────────────┘
```

### 使用示例

```typescript
// 1. 创建 Store
import create from 'zustand';

interface AppState {
  notes: Note[];
  loading: boolean;
  loadNotes: () => Promise<void>;
  deleteNote: (id: string) => Promise<void>;
}

const useStore = create<AppState>((set, get) => ({
  // 状态
  notes: [],
  loading: false,
  
  // 异步操作
  loadNotes: async () => {
    set({ loading: true });
    
    const response = await chrome.runtime.sendMessage({ 
      type: MessageType.GET_NOTES 
    });
    
    set({ 
      notes: response.notes,
      loading: false
    });
  },
  
  // 同步操作
  deleteNote: async (id: string) => {
    // 先乐观更新 UI
    set(state => ({
      notes: state.notes.filter(n => n.id !== id)
    }));
    
    // 再调用 API
    await chrome.runtime.sendMessage({ 
      type: MessageType.DELETE_NOTE,
      payload: { id }
    });
  }
}));

// 2. 在组件中使用
function NoteList() {
  // 选择性订阅：只订阅 notes，不订阅 loading
  const notes = useStore(state => state.notes);
  const deleteNote = useStore(state => state.deleteNote);
  
  return (
    <div>
      {notes.map(note => (
        <NoteCard 
          key={note.id} 
          note={note} 
          onDelete={() => deleteNote(note.id)} 
        />
      ))}
    </div>
  );
}

// 3. 选择性订阅的好处
function LoadingIndicator() {
  // 只订阅 loading，notes 变化不会触发重渲染
  const loading = useStore(state => state.loading);
  
  return loading ? <Spinner /> : null;
}
```

---

## 6. Vite 多入口构建

### 问题：Chrome 扩展有多个独立的运行环境

```
需要分别打包：
- popup/index.html → popup/index.js
- sidepanel/index.html → sidepanel/index.js
- background/service-worker.ts → background/service-worker.js
- background/offscreen.ts → background/offscreen.js
- content/content.ts → content/content.js
```

### Vite 配置

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        'popup/index': resolve(__dirname, 'src/popup/index.html'),
        'sidepanel/index': resolve(__dirname, 'src/sidepanel/index.html'),
        background: resolve(__dirname, 'src/background/service-worker.ts'),
        offscreen: resolve(__dirname, 'src/background/offscreen.ts'),
        content: resolve(__dirname, 'src/content/content.ts'),
      },
      output: {
        entryFileNames: (chunkInfo) => {
          if (chunkInfo.name === 'background') 
            return 'background/service-worker.js';
          if (chunkInfo.name === 'offscreen') 
            return 'background/offscreen.js';
          if (chunkInfo.name === 'content') 
            return 'content/content.js';
          if (chunkInfo.name.startsWith('popup')) 
            return 'popup/index.js';
          if (chunkInfo.name.startsWith('sidepanel')) 
            return 'sidepanel/index.js';
          return 'assets/[name]-[hash].js';
        }
      }
    }
  }
});
```

### 构建结果

```
dist/
├── popup/
│   ├── index.html
│   └── index.js
├── sidepanel/
│   ├── index.html
│   └── index.js
├── background/
│   ├── service-worker.js
│   ├── offscreen.html
│   └── offscreen.js
├── content/
│   ├── content.js
│   └── content.css
├── assets/
│   ├── client-xxx.js (共享代码)
│   ├── types-xxx.js (共享代码)
│   └── index-xxx.css (共享样式)
└── manifest.json
```

---

## 7. 关键代码片段速查

### 文本选择监听
```typescript
document.addEventListener('mouseup', () => {
  const selection = window.getSelection();
  const text = selection?.toString().trim();
  
  if (text && text.length > 10) {
    showFloatingButton(text);
  }
});
```

### 消息传递
```typescript
// 发送
chrome.runtime.sendMessage({
  type: MessageType.COLLECT_TEXT,
  payload: { text, url, title }
});

// 接收
chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
  if (msg.type === MessageType.COLLECT_TEXT) {
    handleCollectText(msg.payload).then(sendResponse);
    return true; // 保持通道开启
  }
});
```

### Chrome Storage
```typescript
// 保存
await chrome.storage.local.set({ 
  webmind_notes: notes 
});

// 读取
const result = await chrome.storage.local.get('webmind_notes');
const notes = result.webmind_notes || [];

// 监听变化
chrome.storage.onChanged.addListener((changes, namespace) => {
  if (namespace === 'local' && changes.webmind_notes) {
    const newNotes = changes.webmind_notes.newValue;
    // 更新 UI
  }
});
```

### AI 调用
```typescript
const summarizer = await window.ai.summarizer.create({
  type: 'tldr',
  format: 'plain-text',
  length: 'medium',
  sharedContext: 'Web content summary',
  monitor(m) {
    m.addEventListener('downloadprogress', (e) => {
      console.log(`下载进度：${Math.round(e.loaded * 100)}%`);
    });
  }
});

const summary = await summarizer.summarize(text);
summarizer.destroy(); // 释放资源
```

### D3 力导向图
```typescript
const simulation = d3.forceSimulation(nodes)
  .force('link', d3.forceLink(links).distance(150))
  .force('charge', d3.forceManyBody().strength(-500))
  .force('center', d3.forceCenter(width/2, height/2))
  .force('collision', d3.forceCollide().radius(60));

simulation.on('tick', updatePositions);
```

### D3 拖拽
```typescript
const drag = d3.drag()
  .on('start', (event, d) => {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  })
  .on('drag', (event, d) => {
    d.fx = event.x;
    d.fy = event.y;
  })
  .on('end', (event, d) => {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  });

nodeElements.call(drag);
```

### Zustand Store
```typescript
const useStore = create<AppState>((set) => ({
  notes: [],
  
  loadNotes: async () => {
    const response = await chrome.runtime.sendMessage({ 
      type: MessageType.GET_NOTES 
    });
    set({ notes: response.notes });
  },
  
  deleteNote: async (id: string) => {
    set(state => ({ 
      notes: state.notes.filter(n => n.id !== id) 
    }));
    await chrome.runtime.sendMessage({ 
      type: MessageType.DELETE_NOTE, 
      payload: { id } 
    });
  }
}));
```

---

## 8. 面试关键数字

| 指标 | 数值 |
|------|------|
| 总代码行数 | ~2,500 行 |
| 核心模块数 | 5 个 |
| React 组件数 | 4 个 |
| 技术栈数量 | 6 个主要技术 |
| 开发时间 | 约 3-4 周 |
| Chrome 权限 | 5 个（最小化） |
| D3.js 力的种类 | 4 种 |
| Offscreen 创建时机 | 按需创建，复用 |
| 默认节点距离 | 150px |
| 电荷力强度 | -500 |
| 碰撞半径 | 60px |
| Zustand 体积 | ~1KB |
| Redux 体积 | ~10KB |

---

## 9. 一句话总结

| 技术点 | 一句话总结 |
|--------|-----------|
| **整体架构** | 5个模块通过消息传递协作，数据存储在本地 |
| **Offscreen** | 创建不可见页面代理调用AI，解决Worker无DOM问题 |
| **D3力导向** | 4种力（弹簧、电荷、中心、碰撞）自动布局节点 |
| **Zustand** | 轻量级状态管理，选择性订阅，无需Provider |
| **Vite构建** | 多入口配置，分别打包5个运行环境 |
| **消息传递** | chrome.runtime.sendMessage + onMessage监听 |
| **存储方案** | chrome.storage.local，本地化，无限容量 |
| **AI调用** | window.ai.summarizer，需用户激活，有降级 |
| **性能优化** | 防抖、memo、虚拟滚动、限制节点数 |
| **隐私保护** | 纯本地，无服务器，符合V3规范 |

---

## 10. 记忆口诀

**项目流程**：
> 选文本 → 显按钮 → 调AI → 存笔记 → 看导图

**5个模块**：
> Content注入 → Background路由 → Offscreen调AI → Popup简单 → SidePanel完整

**4种力**：
> 弹簧拉近 电荷推远 中心聚拢 碰撞分散

**技术栈**：
> React写UI TypeScript保类型 Zustand管状态 D3画导图 Vite来构建 ChromeAPI通信

---

希望这些图解能帮助你快速理解项目的核心技术！

记住：面试时要画图，图比文字更直观！🎨

